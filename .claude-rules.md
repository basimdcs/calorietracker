# Claude Code Development Rules

## Core Principles

### 1. **NEVER GUESS APIs - Always Verify First**
- Before using any external library API, ALWAYS check the actual documentation or inspect the module
- Use `console.log(Object.keys(module))` to see available exports
- Use the Task tool to fetch latest documentation when uncertain
- Never assume API patterns from other libraries or previous versions

### 2. **Read Before Writing**
- ALWAYS use the Read tool to examine existing code before making changes
- Understand the current implementation patterns before modifying
- Check imports, exports, and existing error handling patterns

### 3. **Test-Driven Debugging**
- When fixing errors, first add debug logging to understand the actual problem
- Use `console.log` to inspect variable states, available methods, and module exports
- Make incremental changes and test each step

### 4. **Error-First Approach**
- Every external API call must be wrapped in try-catch
- Provide meaningful error messages that help diagnose the issue
- Never suppress errors - always log them with context

## Expo/React Native Specific Rules

### 1. **Native Module Safety**
- NEVER import native modules at the top level of components
- Always use dynamic imports: `await import('expo-audio')`
- Implement proper lazy loading to prevent crashes on component mount
- Check Platform.OS before using platform-specific APIs

### 2. **Hook Usage Rules**
- React hooks can ONLY be called at the top level of components
- NEVER call hooks inside callbacks, conditions, or loops
- If you need dynamic behavior, use useRef and state management instead
- When refactoring from hooks to non-hook patterns, ensure no hook violations remain

### 3. **State Management**
- Use local state for component-specific data
- Clean up timers, intervals, and subscriptions in useEffect cleanup
- Always clear refs on component unmount or state reset

## Code Quality Standards

### 1. **Dependency Management**
- Remove stale references from dependency arrays
- Use empty dependency arrays `[]` when callbacks don't depend on changing values
- Don't include refs in dependency arrays (they don't change)

### 2. **Error Handling Hierarchy**
```typescript
try {
  // Primary approach
} catch (primaryError) {
  try {
    // Fallback approach
  } catch (fallbackError) {
    // Graceful degradation
    console.error('All approaches failed:', { primaryError, fallbackError });
    // User-friendly error message
  }
}
```

### 3. **Performance Optimization**
- Always implement proper cleanup (timeouts, intervals, subscriptions)
- Use lazy loading for expensive operations
- Optimize media settings for file size when dealing with audio/video

## Debugging Methodology

### 1. **Systematic Debugging Process**
1. **Understand the Error**: Read the full error message and stack trace
2. **Locate the Source**: Find the exact line and understand the context
3. **Inspect the State**: Log relevant variables and module contents
4. **Test Incrementally**: Make small changes and test each step
5. **Verify the Fix**: Ensure the solution works and doesn't break other features

### 2. **Logging Standards**
```typescript
console.log('🔍 Debug:', { variable, state, available: Object.keys(module) });
console.log('✅ Success:', 'Operation completed');
console.log('⚠️ Warning:', 'Potential issue detected');
console.error('❌ Error:', error);
```

### 3. **Documentation Verification**
- When working with external libraries, ALWAYS check the latest documentation
- Use the Task tool to fetch current API documentation
- Don't rely on Stack Overflow answers that might be outdated
- Verify the library version in package.json

## React Native & Expo Patterns

### 1. **Understanding Expo Architecture**

#### **Expo Native Modules vs React Components:**
- **Native Modules** (expo-audio, expo-camera, etc.): Access device hardware/OS features
- **React Components**: UI rendering and state management
- **Key Rule**: Native modules require proper initialization and permission handling

#### **Expo Hook-Based Architecture (v14+)**
Modern Expo libraries (expo-audio v14+) use **hook-based architecture**:
- Hooks MUST be called at component top level (Rules of Hooks)
- No direct class constructors (no `new Recording()`)
- State is managed internally by hooks
- Cleanup is handled automatically

### 2. **Safe Native Module Access Patterns**

#### **Pattern 1: Hook-Based Modules (Preferred for expo-audio v14+)**
```typescript
// ✅ CORRECT - Direct import and hook usage
import { useAudioRecorder, useAudioRecorderState, RecordingPresets } from 'expo-audio';

const MyComponent = () => {
  // Hooks called at component top level
  const audioRecorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);
  const recorderState = useAudioRecorderState(audioRecorder);
  
  const startRecording = async () => {
    await audioRecorder.prepareToRecordAsync();
    audioRecorder.record();
  };
  
  return <View>...</View>;
};

// ❌ WRONG - Trying to use class constructors
const badApproach = async () => {
  const module = await import('expo-audio');
  const recorder = new module.Recording(); // This doesn't exist in v14+
};

// ❌ WRONG - Calling hooks in callbacks
const handlePress = () => {
  const recorder = useAudioRecorder(); // Hook violation!
};
```

#### **Pattern 2: Legacy Module Access (for older APIs)**
```typescript
// ✅ CORRECT - For modules without hooks
const loadModule = async () => {
  try {
    const module = await import('expo-legacy-module');
    console.log('Available exports:', Object.keys(module));
    return module;
  } catch (error) {
    console.error('Module not available:', error);
    throw new Error('Module not supported on this platform');
  }
};
```

### 3. **Expo Audio Specific Patterns (v14)**

#### **Recording Pattern:**
```typescript
import { 
  useAudioRecorder, 
  useAudioRecorderState, 
  AudioModule, 
  setAudioModeAsync,
  RecordingPresets 
} from 'expo-audio';

const VoiceRecorder = () => {
  // 1. Create recorder with preset
  const audioRecorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);
  const recorderState = useAudioRecorderState(audioRecorder);
  
  // 2. Initialize permissions and audio mode
  useEffect(() => {
    const init = async () => {
      const { granted } = await AudioModule.requestRecordingPermissionsAsync();
      if (granted) {
        await setAudioModeAsync({
          allowsRecording: true,
          playsInSilentMode: true,
        });
      }
    };
    init();
  }, []);
  
  // 3. Recording controls
  const startRecording = async () => {
    await audioRecorder.prepareToRecordAsync();
    audioRecorder.record();
  };
  
  const stopRecording = async () => {
    await audioRecorder.stop();
    const uri = audioRecorder.uri; // File URI available here
  };
  
  // 4. Use state from hooks
  return (
    <View>
      <Text>Recording: {recorderState.isRecording ? 'Yes' : 'No'}</Text>
      <Text>Time: {recorderState.currentTime}s</Text>
    </View>
  );
};
```

#### **Key expo-audio v14 Rules:**
1. **No Direct Constructors**: Never use `new Recording()` or `new AudioRecorder()`
2. **Hook-Only API**: Use `useAudioRecorder()` and `useAudioRecorderState()`
3. **Component-Level Hooks**: Hooks must be called at component top level
4. **Built-in State**: Use `recorderState.isRecording`, `recorderState.currentTime`
5. **Automatic Cleanup**: Hooks handle cleanup automatically

### 4. **Permission Handling Patterns**
```typescript
// ✅ CORRECT - Proper permission flow
const requestPermissions = async () => {
  try {
    const { granted } = await AudioModule.requestRecordingPermissionsAsync();
    if (!granted) {
      Alert.alert('Permission Required', 'Microphone access is needed');
      return false;
    }
    
    await setAudioModeAsync({
      allowsRecording: true,
      playsInSilentMode: true,
    });
    
    return true;
  } catch (error) {
    console.error('Permission error:', error);
    return false;
  }
};
```

### 2. **Component Lifecycle Management**
```typescript
// ✅ CORRECT
useEffect(() => {
  return () => {
    // Cleanup ALL resources
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    if (intervalRef.current) clearInterval(intervalRef.current);
    if (subscriptionRef.current) subscriptionRef.current.remove();
  };
}, []);
```

### 3. **Fallback Patterns**
```typescript
// ✅ CORRECT - Multiple fallback strategies
const attemptOperation = async () => {
  // Try modern API
  try {
    return await modernAPI.operation();
  } catch (modernError) {
    console.log('Modern API failed, trying legacy:', modernError);
    
    // Try legacy API
    try {
      return await legacyAPI.operation();
    } catch (legacyError) {
      console.log('Legacy API failed, using simulation:', legacyError);
      
      // Graceful degradation
      return simulateOperation();
    }
  }
};
```

## File Organization Rules

### 1. **Import Organization**
```typescript
// 1. React imports
import React, { useState, useCallback } from 'react';

// 2. React Native imports
import { View, Text } from 'react-native';

// 3. Third-party libraries
import { MaterialIcons } from '@expo/vector-icons';

// 4. Local imports
import { colors } from '../constants/theme';
import { CustomComponent } from '../components/CustomComponent';
```

### 2. **Error Boundary Patterns**
- Always implement error boundaries for components that use native modules
- Provide meaningful fallback UI when native features fail
- Never let native module errors crash the entire app

## Testing & Validation

### 1. **Pre-commit Checklist**
- [ ] No console.errors in production code (only console.log for debugging)
- [ ] All timeouts and intervals are properly cleaned up
- [ ] No stale dependencies in useCallback/useEffect arrays
- [ ] All native module imports are lazy-loaded
- [ ] Error handling is implemented for all external API calls

### 2. **Cross-platform Considerations**
- Test on both iOS and Android when using native modules
- Implement platform-specific fallbacks when necessary
- Check simulator vs. device behavior differences

## Common Anti-patterns to Avoid

### 1. **Expo-Audio Specific Anti-patterns**
```typescript
// ❌ WRONG - Trying to use old expo-av patterns
const badRecording = async () => {
  const expoAudio = await import('expo-audio');
  const recording = new expoAudio.Recording(); // Doesn't exist in v14!
  await recording.prepareToRecordAsync();
};

// ❌ WRONG - Dynamic hook creation
const createRecorder = async () => {
  const expoAudio = await import('expo-audio');
  return expoAudio.useAudioRecorder(); // Hook called outside component!
};

// ❌ WRONG - Lazy loading hooks
const handlePress = async () => {
  const expoAudio = await import('expo-audio');
  const recorder = expoAudio.useAudioRecorder(); // Hook violation!
};

// ✅ CORRECT - Proper expo-audio v14 pattern
import { useAudioRecorder, useAudioRecorderState, RecordingPresets } from 'expo-audio';

const MyComponent = () => {
  const audioRecorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);
  const recorderState = useAudioRecorderState(audioRecorder);
  
  const handlePress = async () => {
    await audioRecorder.prepareToRecordAsync();
    audioRecorder.record();
  };
  
  return <Button onPress={handlePress}>Record</Button>;
};
```

### 2. **Hook Violations**
```typescript
// ❌ WRONG
const handleClick = () => {
  const recorder = useAudioRecorder(); // Hooks can't be called in callbacks
};

// ✅ CORRECT
const recorder = useAudioRecorder(); // Hook called at top level
const handleClick = () => {
  recorder.record();
};
```

### 2. **Circular Dependencies**
```typescript
// ❌ WRONG
const [state, setState] = useState(0);
useEffect(() => {
  setState(state + 1); // Creates infinite loop
}, [state]);

// ✅ CORRECT
const [state, setState] = useState(0);
useEffect(() => {
  setState(prev => prev + 1); // Use callback pattern
}, []); // Or remove state from dependencies
```

### 3. **Memory Leaks**
```typescript
// ❌ WRONG
const handleAsync = async () => {
  const result = await longOperation();
  setState(result); // Component might be unmounted
};

// ✅ CORRECT
const handleAsync = async () => {
  const result = await longOperation();
  if (mountedRef.current) {
    setState(result);
  }
};
```

## Emergency Recovery Procedures

### 1. **When Everything Breaks**
1. Revert to the last working version
2. Identify the minimal change that caused the issue
3. Add comprehensive debugging to understand the failure
4. Implement with proper error handling and fallbacks

### 2. **Expo-Audio Specific Troubleshooting**

#### **"Cannot read property 'prototype' of undefined"**
- **Cause**: Trying to use `new Recording()` (expo-av pattern) in expo-audio v14
- **Solution**: Use `useAudioRecorder()` hook instead
- **Debug**: Log `Object.keys(expoAudio)` to see available exports

#### **"Hook called outside component"**
- **Cause**: Calling `useAudioRecorder()` in callback or async function
- **Solution**: Move hook call to component top level
- **Debug**: Ensure all hooks are called before any returns or conditions

#### **"NativeSharedObjectNotFoundException"**
- **Cause**: Accessing native modules before proper initialization
- **Solution**: Don't import hooks at top level if component mounts immediately
- **Debug**: Use lazy imports for components with immediate native access

#### **Recording returns null URI**
- **Cause**: Recording not properly prepared or permissions denied
- **Solution**: Check permissions and call `prepareToRecordAsync()` first
- **Debug**: Log `recorderState` to see actual recording status

### 3. **Native Module Issues**
1. Check if the module is properly installed and linked
2. Verify the module works on the target platform
3. Add debug logging to see what's actually available
4. Implement graceful degradation for unsupported platforms

### 4. **Expo-Audio Debugging Checklist**
```typescript
// Add this debugging code when expo-audio fails
const debugExpoAudio = async () => {
  try {
    const expoAudio = await import('expo-audio');
    console.log('📦 Available exports:', Object.keys(expoAudio));
    console.log('🎤 useAudioRecorder:', !!expoAudio.useAudioRecorder);
    console.log('📊 useAudioRecorderState:', !!expoAudio.useAudioRecorderState);
    console.log('⚙️ RecordingPresets:', !!expoAudio.RecordingPresets);
    console.log('🔐 AudioModule:', !!expoAudio.AudioModule);
    
    // Check permissions
    const { granted } = await expoAudio.AudioModule.requestRecordingPermissionsAsync();
    console.log('🎯 Permission granted:', granted);
  } catch (error) {
    console.error('❌ Expo-audio debug failed:', error);
  }
};
```

---

## Summary

**The golden rule: When in doubt, debug first, implement second.**

Never guess at APIs. Always verify what's available, understand the current state, and implement with proper error handling and fallbacks.